#Jika belum install package Kohonen
install.packages("kohonen")

#Memanggil library yang diperlukan
library(kohonen)
library(dplyr)

#Data Pre-Processing
#Import Dataset

#Melihat isi Dataset
data <- Kuisoner_Penelitian %>% 
  glimpse()
  
#Menghapus Kolom 'No' dan 'Nama'
Kuisoner_Penelitian[ , c('No', 'Nama')] <- list(NULL) 

#Melihat ringkasan atau statistika deskriptif data kuisoner penelitian
summary(Kuisoner_Penelitian) 

#mengubah tipe data yang bukan numeric menjadi numeric
Kuisoner_Penelitian[] <- lapply(Kuisoner_Penelitian, function(x) {
  if(is.factor(x)) as.numeric(as.character(x)) else x
})
sapply(Kuisoner_Penelitian, class)

#melihat struktur data setelah diubah tipe datanya
str(Kuisoner_Penelitian)

#melihat dimensi data
dim(Kuisoner_Penelitian)

#Melakukan Standarisasi atau Normalisasi untuk Data Training
# make a train data sets that scaled and convert them to be a matrix cause kohonen function accept numeric matrix
data.train <- as.matrix(scale(Kuisoner_Penelitian))

# make stable sampling
RNGkind(sample.kind = "Rounding")

# make a SOM grid
set.seed(100)
data.grid<- somgrid(xdim = 5, ydim = 5, topo = "hexagonal")
data.grid

# make a SOM model
set.seed(100)
data.model <- som(data.train, data.grid, rlen = 500, radius = 2.5, keep.data = TRUE,
                 dist.fcts = "euclidean")
                 
# str(data.model)
#Dari ringkasan ads.model itu kita tahu bahwa grid SOM kita memiliki dimensi 5Ã—5.

#Unsupervised SOM
#Sebelum memvisualisasikan model SOM, mari kita telusuri daftar model SOM. Jika kita ingin mengetahui posisi data kita di peta, kita lihat di unit.classif. Setiap nilai mewakili nomor simpul tempat aplikasi ini berada. Misalnya pada aplikasi pertama nilai 12 berarti pada aplikasi pertama telah diklasifikasikan menjadi 12 node tertentu.
head(data.model$unit.classif)

#Dan kita dapat melihat klasifikasi setiap node dengan plot kode dan kita dapat melihat nilai dari setiap node menggunakan plot pemetaan.
plot(data.model, type = "mapping", pchs = 19, shape = "round")  

head(data.frame(data.train), 5)

plot(data.model, type = "codes", main = "Codes Plot", palette.name = rainbow)

#Node Count
#Node yang diwarnai merah berarti node yang memiliki nilai input paling sedikit, seperti pada node kedua. Jika node warna lebih cerah menunjukkan node memiliki banyak nilai input, seperti pada 31 node. Untuk node yang memiliki warna abu-abu, artinya node tersebut tidak memiliki nilai input sama sekali.
plot(data.model, type = "counts")

#Neighbours Nodes
#Jika kita ingin melihat node yang memiliki tetangga terdekat atau terjauh, kita dapat memplot plot berdasarkan dist.neighbours. Node yang memiliki warna lebih gelap berarti node tersebut memiliki input vektor yang lebih dekat, sedangkan node yang memiliki warna lebih terang berarti node tersebut memiliki input vektor yang jaraknya lebih jauh.
plot(data.model, type = "dist.neighbours")

#Heatmaps
#10 untuk heatmaps dari 10 variabel pertama
heatmap.som <- function(model){
  for (i in 1:10) {
    plot(model, type = "property", property = getCodes(model)[,i], 
         main = colnames(getCodes(model))[i]) 
  }
}
heatmap.som(data.model)

#Clustering
#Jika ingin menentukan jumlah cluster dg metode Elbow
#library(factoextra)
#set.seed(100)
#fviz_nbclust(data.model$codes[[1]], kmeans, method = "wss")

#Clustering dengan KMeans
#3 adalah jumlah kluster yang diinginkan
set.seed(100)
clust <- kmeans(ads.model$codes[[1]], 3)

# clustering using hierarchial
# cluster.som <- cutree(hclust(dist(data.model$codes[[1]])), 3)

#Visualisasi Hasil Clustering
plot(data.model, type = "codes", bgcol = rainbow(9)[clust$cluster], main = "Cluster Map")

add.cluster.boundaries(ads.model, clust$cluster)

#source : https://algoritmaonline.com/self-organizing-maps/?fbclid=IwAR06N22HNhbcQRtrX_6PA6-RCQJWNEbhKtuSZyEMOgZcfPaTwSL3OUOSR-w
